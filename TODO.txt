database http://www.cs.princeton.edu/courses/archive/fall06/cos402/papers/korfrubik.pdf

optimizing
	google array
	multithreading
		custom solution
	fix Solver setup
	swap instead of delete
		new system should easily allow that
	use 128bits instead of vector<Movement>
		incrementation << 4 | m+-1
		get size
		translation
	check cache misses
		cachegrind
	remove duplicate nodes
		Thus, for each pair of opposite faces we
		arbitrarily chose an order, and forbid moves that twist
		the two faces consecutively in the opposite order
		more ?
heuristic
	maybe relative distance instead of absolute
		that way the computer tries to place a border between corners instead of not
			maybe for invalid
			each corners has 3 corner neighbours && 3 border neighbours
			each side has 2 corner neighbours and 2 center neighbours
			each center has 4 borders and 4 corners
	the ideal heuristic would realize that the square can
		go directly to the target (center)
		go to a friend(border/center), that can be moved to the center/
		maybe corners try to move next to their borders instead?
	considering corner parity
		http://math.stackexchange.com/questions/127577/how-to-tell-if-a-rubiks-cube-is-solvable

input
	direct color input
		get cube_id
		check presence
		if each cubes are present, and no impossible match,
			then
		check if possible
			http://math.stackexchange.com/questions/127577/how-to-tell-if-a-rubiks-cube-is-solvable
		id_from_data

new array system

is it getcube id ?
	{Index_U, 0, 0} {Index_L, 0, 0} {Index_B, 0, 2} 0
	{Index_U, 0, 2} {Index_B, 0, 0} {Index_R, 0, 2} 1
	{Index_U, 2, 0} {Index_F, 0, 0} {Index_L, 0, 2} 2
	{Index_U, 2, 2} {Index_R, 0, 0} {Index_F, 0, 2} 3
	{Index_D, 0, 0} {Index_L, 2, 2} {Index_F, 2, 0} 4
	{Index_D, 0, 2} {Index_F, 2, 2} {Index_R, 2, 0} 5
	{Index_D, 2, 0} {Index_B, 2, 2} {Index_L, 2, 0} 6
	{Index_D, 2, 2} {Index_R, 2, 2} {Index_B, 2, 0} 7